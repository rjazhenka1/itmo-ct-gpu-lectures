# Сумма двух чисел

Поговорим об OpenCL.

Первое понятие - **Платформа**.

**Платформа** - это, фактически одна реализация OpenCL.

Если у вас есть одна видеокарта, и есть одна реализация OpenCL для CPU, то у вас 2 платформы.

Если у вас есть видеокарта от Intel и есть видеокарта от NVIDIA, то у вас тоже 2 платформы.

Но если у вас 2 видеокарты от NVIDIA, то у вас 1 платформа, но два **устройства**.

Перечислить все платформы - функция `clGetPlatfromIDs`.

Как это скомпилировать? Хэдеры можно скачать буквально на официальном сайте OpenCL. Достаточно подключить хедер `<CL/cl.h>`.

А вот сделать линковку посложнее. Нужно, собственно, скачать сами библиотеки.

С Linux все понятно. Выберите ваш любимый пакетный менеджер и скачайте через него.

С Windows где-то надо скачать, но тоже большую проблему не представляет. Способов несколько, стоит найти в Интернете.

`clGetPlatfromIDs` возвращает код ошибки **(Как и большинство функций OpenCL!!!)**. `0` - OK. Не `0` - ошибка.

Ставьте проверки заранее!!! Чем раньше узнаете об ошибке - тем лучше. В каких-то функциях Скаков будет говорить, что проверять ошибку обязательно. В остальных необязательно, но полезно.

> Не связанный fun fact - `zlib` настолько пример старого кода, что в 23 стандарте C он просто отказался компилироваться, потому что там ...

Отличие функций `createXxxxx` - они возвращают объект. Поэтому у них есть аргумент - указатель на переменную, куда записать код ошибки.

`clGetPlatfromIDs(размер буфера, указатель на буфер, куда записать I)`. `clGetPlatfromIDs` сама память не выделяет, надо выделять вам самим.

Как решить проблему с выделением памяти? Есть вариант с 3 аргументами. Если подать в функцию аргументы `NULL, 0`, то в последний аргумент запишется размер необходимого буфера. После этого можно уже выделить память так, как удобно.

Соответственно, от нас часто ожидается паттерн типа

```c
{
    ...
    cl_uint size;
    clFunction(NULL, 0, &size);
    void * buf = ... <как-то выделить>;
    clFunction(buf, size, NULL);
    ...
}
```

Теперь, если мы хотим получить информацию о платформе, то используем функцию `clGetPlatformInfo`. Она еще принимает ID нужной платформы. Остальные аргументы как до этого (указатель на буфер, размер, указатель на размер);

Теперь нужно найти **устройства**, на которых запускать, собственно код. С устройствами на одной платформе достаточно безболезненно устроить взаимодействие с общими данными. На разных платформах данные надо будет вручную передавать.

Для этого есть функция `clGetDeviceIDs`. Первые два аргумента - ID платформы и тип девайсов, которые хотим получить. Какие есть **типы девайсов**:

- CL_DEVICE_TYPE_CPU
- CL_DEVICE_TYPE_GPU
- CL_DEVICE_TYPE_ACCELERATOR
- CL_DEVICE_TYPE_CUSTOM
- CL_DEVICE_TYPE_DEFAULT
- CL_DEVICE_TYPE_ALL

В лабораторных Скаков будет требовать поддержку всех типов девайсов, но будет просить сортировать их в определенном порядке (сначала видеокарты, потом что-то еще).

Аналогично есть `clGetDeviceInfo`.

Можно использовать несколько девайсов внутри одной платформы, но мы так делать не будем. Просто выберем одно лучшее устройство и будем с ним работать.

> Сейчас мы со Скаковым выбрали одно устройство в OpenCL и вывели что-то про него...

Теперь, собственно, надо создать контекст, с которым мы будем работать. Для этого есть функция `clCreateContext`. Принимает количество устройств, указатель на буфер с нужными ID и функция `callback`, который вызывается, когда какая-то ошибка происходит. Контекст - начало осмысленной работы с девайсом.

`clCreateProgramWithSource` - это функция, которая в контекст грузит исходные файлы OpenCL. Обычно советуют хранить файлы исходников в `.cl` файлах. Тогда нужно прочитать текстовый файл в память и затолкать его содержимое в `clCreateProgramWithSource`. Принимает контекст, количество текстовых файлов на входе, список указателей на **строки с содержимым .cl файлов** (`char**`), список длин этих строк (`size_t*`), список указателей на переменные, где будут храниться коды ошибок (`cl_int*`). Возвращает `cl_program`.

`cl_int clBuildProgram(cl_program program, cl_uint num_devices, const cl_device_id *device_list, const char *options, callback, void *user_data)` - даст нам скомпилированные бинарники. **Вот они уже не кроссплатформенные, не надо их куда-то передавать! Они могут зависеть даже от версии драйвера!! Вот тут надо обязательно обрабатывать ошибку!** В `const char* options` не передавайте `NULL`, передавайте пустую строчку. Не все платформы адекватно обрабатывают `NULL`.

`clGetProgramBuildInfo` дает **логи компиляции**. Пользуйтесь им, пожалуйста!!!

Пример OpenCL-кода, который компилируется:

```c
kernel void add(global const int *a, global const int *b, global int *c) {
    *c = *a + *b;
}
```

Почти как Си! Отличия:

- Есть `kernel`, которая делает эту функцию `kernel` (цитата). `kernel` - потенциальная "точка входа" в программу. Их может быть несколько. `kernel`-функции всегда `void`, поэтому результат возвращаем через указатель.
- Есть `global`. О нем мы поговорим попозже.

`a`, `b` и `c` находятся в регистрах, указывают на оперативную память.

`cl_kernel clCreateKernel(cl_program program, const char* kernel_name,  cl_int* errcode_ret)` Это создает идентификатор, через который можно будет вызвать Kernel.

Следующий шаг - выделить память на девайсе.

Для этого у нас есть `cl_mem clCreateBuffer(...)`. Передаем размер буфера и флаг способа взаимодействия `kernel`'а с памятью (read-only, write-only, read-write). Из хоста можно будет с этой памятью взаимодействовать вне зависимости от флага.

В нашем примере надо 3 буфера - для `a`, для `b`, для `c`.

`int` на девайсе - это `cl_int` на хосте. Слово `size_t` запрещено, потому что на хосте и девайсе они могут отличаться. Но размеры `int, short, long` гарантированы адекватные (32, 16, 64 соответственно). Хотим узнать размер инта девайса на хосте - `sizeof(cl_int)`. `float` и `double` адекватные. Но `double` и `half` не гарантированы. Надо спрашивать девайс.

Теперь можем накормить наш `kernel` аргументами. Вызываем `clSetKernelArg`. Принимает `kernel`, номер аргумента, адрес значения, длину значения.

В нашем примере придется это сделать 3 раза для каждого аргумента.

Теперь заполним буферы чем-нибудь, потому что пока там мусор. `cl_mem` это не совсем указатель, это *handler*.

`clCreateCommandQueue` - создадим очередь команд.

В нее будем ставить задания для нашего девайса:

`clEnqueueWriteBuffer`. Параметров много. Нужно передать очередь, буфер, еще разные штуки. Есть параметр про Out-of-Order Execution. Не ставьте его, а то будете удивляться, почему прога не работает. А то с этим флажочком задания выполняются в произвольном порядке и надо будет их ручками синхронизировать. Можно еще делать передачу данных блокирующей.

Есть еще `clEnqueueReadBuffer`. Ее, понятно, будем использовать после

Скаков советует делать записи на устройство не блокирующими, чтобы быстрее работало, а потом делать последнее чтение с устройства блокирующим. Есть, конечно, функция для того, чтобы явно блокировать устройство, но она не то чтобы полезная.

Вопрос: На каком устройстве выделяется память с помощью `clCreateBuffer`.

Ответ: На любом. Она выделяется только в тот момент, когда начинает использоваться (в нее чет пишут). Если памяти не хватило сейчас, то и не хватит позже.

Для полного счастья осталось вызвать наш `kernel`. Для этого используем функцию `clEnqueueNDRangeKernel`. Она принимает `dimension`, о чем поговорим позже. Пока поставим 1. Потом есть `global_work_size`, туда пока затолкаем 1. В `local_work_size` положим NULL, как и во всякие `*events`.  

Осторожнее в девайс-коде:

---

Кстати, память-то надо освобождать потом и удалять штуки после Create: Create заменить на Release везде, кроме Buffer.
Там clReleaseMemObject.

---

Мы живем в OpenCL 1.2. Хотя есть вот и OpenCL 2 и 3, но NVIDIA обломала кайф и 2 почему-то не захотела поддерживать. OpenCL 3 сделал многое из 2 опциональным, и вот его NVIDIA поддержать согласилась.

> Рассказ про то, какой Vulkan убогий...

Vulkan вроде бы поближе к железу, а не программисту, собственно, поэтому такой тяжелый для изучения.

---

Задание всем - довести до работающего состояния наш `a + b`, выводить логи сборки.

--- Пример решения:

`CMakeLists.txt`:

```cmake
cmake_minimum_required(VERSION 3.20)
project(ocl1 C)

set(OPENCL_VERSION "1.2")
set(CL_TARGET_OPENCL_VERSION "100")

find_package(OpenCL REQUIRED)
add_executable(ocl1 main.c)
target_include_directories (ocl1 PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
target_link_libraries(ocl1 OpenCL::OpenCL)
```

`aplusb.cl`:

```c
kernel void add(global const int *a, global const int *b, global int *c) {
  *c = *a + *b;
}
```

`main.c`:

```c
#ifdef __APPLE__
#include <OpenCL/cl.h>
#else
#include <CL/cl.h>
#endif

#include <assert.h>
#include <stdio.h>

int main() {
  // Получим список ID платформ
  cl_uint platform_count;
  clGetPlatformIDs(0, NULL, &platform_count);
  printf("%u platforms found.\n", platform_count);
  cl_platform_id *platform_ids =
      malloc(platform_count * sizeof(cl_platform_id));
  clGetPlatformIDs(platform_count, platform_ids, NULL);
  cl_platform_id platform_id = platform_ids[0];
  printf("Using first available platform\n");

  // Получим список ID устройств
  cl_uint device_count;
  clGetDeviceIDs(platform_ids[0], CL_DEVICE_TYPE_ALL, 0, NULL, &device_count);
  printf("%u devices found.\n", device_count);
  cl_device_id *device_ids = malloc(device_count * sizeof(cl_device_id));
  clGetDeviceIDs(platform_ids[0], CL_DEVICE_TYPE_ALL, device_count, device_ids,
                 NULL);
  cl_device_id device_id = device_ids[0];
  printf("Using first available device\n");

  // Создадим контекст программы
  cl_context context = clCreateContext(NULL, 1, &device_id, NULL, NULL, NULL);

  // Загрузим программу в контекст
  FILE *aplusb_file =
      fopen("/home/ildar/documents/uni/6sem/gpu/lec/code/2/aplusb.cl",
            "rb");                 // Откроем файл
  fseek(aplusb_file, 0, SEEK_END); // Поставим указатель на конец
  size_t aplusb_size = ftell(aplusb_file); // Запишем позицию конца
  fseek(aplusb_file, 0, SEEK_SET); // Вернемся в начало файла

  char *aplusb_source =
      malloc(aplusb_size + 1); // Выделим буфер под содержимое файла
  fread(aplusb_source, aplusb_size, 1, aplusb_file); // Считаем содержимое файла
  fclose(aplusb_file);
  aplusb_source[aplusb_size] = 0; // Строки в Си оканчиваются на ноль!

  cl_program program =
      clCreateProgramWithSource(context, 1, (const char **)&aplusb_source,
                                (const size_t *)&aplusb_size, NULL);

  // Скомпилируем программу
  cl_int build_err = clBuildProgram(program, 1, &device_id, "", NULL, NULL);

  // Получим логи
  size_t log_size;
  clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, 0, NULL,
                        &log_size);
  char *log = malloc(log_size);
  clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, log_size, log,
                        NULL);
  printf("Build log:\n%s\n", log);
  free(log);

  // Проверим успешность компиляции
  if (build_err != 0) {
    printf("Could not build program! See log for details.\n");
    return -2;
  }

  printf("Built program successfully!\n");

  // Создадим очередь команд
  cl_command_queue command_queue = clCreateCommandQueue(context, device_id, 0, NULL);
  
  // Получим идентификатор kernel'а
  cl_kernel kernel = clCreateKernel(program, "add", NULL);

  // Выделим память на девайсе и поставим ее как аргументы kernel'а
  cl_mem a_mem =
      clCreateBuffer(context, CL_MEM_READ_ONLY, sizeof(cl_int), NULL, NULL);
  clSetKernelArg(kernel, 0, sizeof(cl_mem), &a_mem);
  cl_mem b_mem =
      clCreateBuffer(context, CL_MEM_READ_ONLY, sizeof(cl_int), NULL, NULL);
  clSetKernelArg(kernel, 1, sizeof(cl_mem), &b_mem);
  cl_mem c_mem =
      clCreateBuffer(context, CL_MEM_WRITE_ONLY, sizeof(cl_int), NULL, NULL);
  clSetKernelArg(kernel, 2, sizeof(cl_mem), &c_mem);

  // Поставим в очередь запись аргументов
  cl_int a = 2, b = 3;
  clEnqueueWriteBuffer(command_queue, a_mem, CL_FALSE, 0, sizeof(cl_int), &a, 0, NULL, NULL);
  clEnqueueWriteBuffer(command_queue, b_mem, CL_FALSE, 0, sizeof(cl_int), &b, 0, NULL,
                       NULL);

  // Поставим в очередь запуск kernel'а
  size_t zero = 0, one = 1;
  clEnqueueNDRangeKernel(command_queue, kernel, 1, NULL, &one, NULL, 0, NULL, NULL);
  
  // Поставим в очередь чтение ответа (в блокирующем режиме, что запустит нашу программу)
  cl_int c;
  clEnqueueReadBuffer(command_queue, c_mem, CL_TRUE, 0, sizeof(cl_int), &c, 0, NULL,
                      NULL);

  // Проверим
  printf("Executed %d + %d successfully, got %d (expected %d).\n", a, b, c, a + b);
  assert(a + b == c);

  // Приберемся напоследок
  clReleaseMemObject(a_mem);
  clReleaseMemObject(b_mem);
  clReleaseMemObject(c_mem);
  clReleaseKernel(kernel);
  clReleaseProgram(program);
  clReleaseCommandQueue(command_queue);
  clReleaseContext(context);
  free(platform_ids);
  free(device_ids);

  return 0;
}
```
