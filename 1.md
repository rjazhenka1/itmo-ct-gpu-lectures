# Введение

На курсе как минимум рассмотрим фреймворк OpenCL. Один из его плюсов в том, что он не ограничен только видеокартами. Его можно запускать на CPU или FPGA.  

Достаточно прикольная штука. Но он не то чтобы стремительно развивается: его разрабатывает консорциум, поэтому они стараются сохранять такие штуки, как обратная совместимость и подобное. CUDA, конечно, развивается, побыстрее, но ее одна компания развивает.

Если времени хватит, то еще поговорим про Vulkan Compute, но это необязательно. Vulkan, возможно, займет место OpenGL как главной кроссплатформенной библиотеки. Vulkan как-то посложнее и точность вычислений будет пониже (`float`, Vulkan просто не так сильно запаривался с точностью деления), но зато пошустрее. Тоже уже примерно везде поддерживается.

Классно, что OpenCLи и Vulkan'ы работают вне зависимости от операционной системы и архитектуры процессора.

Конечно, Apple хочет OpenCL установить как устаревший (deprecated) в пользу своего Metal, но есть wrapper'ы, которые транслируют из одного в другое. Иронично, что OpenCL изначально спонсировала вообще Apple!!! (что очень на них не похоже), потому что они хотели помешать NVIDIA и не застрять на CUDA.

CUDA трогать не будем, а то они от NVIDIA. Фу.

В прошлом году было 6 человек на курсе, 3 из которых закрылись во время сессии, 1 на дополнительной сессии.

Пишем на OpenCL.
Его можно поделить на так называемый **Host Code**, который общается с драйвером OpenCL и **Device Code**, который, собственно, на самом устройстве исполняется.

С **Device Code** все понятно, он просто на OpenCL пишется, он базируется на C99.
**Host Code** можно много на чем писать, но Скаков просит остановиться на C/C++.
Есть API под C, есть обертка для C++, но обертка под C++ не сильно что-то идейное привносит. Там в основном только функции.

Дадут доступ к серверу на Windows, чтобы сделать замеры скорость (profiling) и оптимизировать при необходимости. Есть отладчик, но там отлаживать грустновато. В целом, если мы пишем по стандарту, то можем верить, что если запускается на одной системе, то и на другой запустится. Правда, иногда со всякими там выравниваниями можно выйти за стандарт и может быть грустно.

Если у вас в ноутбуке встроенная и дискретная, то есть аж 2 видеокарты, на которых можно протестировать работоспособность.

Как всегда: "Если у вас мак, то разберитесь сами. **Если вы под Windows, то я могу помочь разобраться**. Что там с линуксом, я не знаю, что там за заморочки".

В начале курса будет какое-то количество лекций (которая все еще будет напрямую связана с лабораторными), потом будем упираться больше в практику. Теории относительно немного,

Не будем совсем хаять CUDA, хоть на ней и не пишем. Для общего развития ее документацию тоже можно будет почитать. Идеи оптимизации там и на OpenCL примерно такие же были.

Теперь еще больше упираемся в оптимизацию. "Программа заработала" - это только начало работы.

---

**Первая лабораторная** супер-классическая - умножение матриц. Порядок действий примерно такой:

- Написать умножение самому на процессоре
- Сделать параллельным (SIMD, код все равно оставить однопоточным) через OpenMP. Если хотите по-другому, то можно по-другому, просто на OpenMP проще всего.
- Переписать на OpenCL
- Протестировать на OpenCL на процессоре и видеокарте

Транспонировать матрицу на хосте (кто-то спрашивал про такую оптимизацию) разрешат тоже.

Runtime для OpenCL естественным образом умеет оптимизировать в SIMD, так что получится вполне себе шустренько, возможно, даже сходу быстрее, чем на CPU.

Если будет желание, Скаков может устроить лекцию по OpenMP.

Первую лабораторную Скаков чуть ли не за ручку будет помогать писать.

**Вторая лабораторная**: "обработка чета реалистичного". Говорит, что не очень сильно надо будет запариваться с синхронизацией и подобными.

**Третья лабораторная**: "чета реалистичное", но посложнее.

---

На лабораторных работах Скаков будет тестировать скорость относительно своего решения. `0.5 * reference_solution` вроде бы будет норм. Виктория говорит, что `0.5x` добыть несложно. А вот сравняться с решением Скакова или обогнать - сложно.

**Дедлайны мягкие!!!**

Если нас будет много, то можно будет устроить рейтинг.
Если мало, то попробуют оформить компьютерный класс с нормальными компами.

---

К следующей лекции поставить:

- OpenCL
- Дрова на видеокарту
- При желании можно поставить Runtime для процессора.

Ну и попробовать запустить всю эту красоту.

Под Windows есть GPU CapsViewer, чтобы посмотреть свойства разных графических API и запустить демонстрационные сцены.

Чтобы проверить, что что-то настроилось, можно написать `clinfo`. Но вообще что-то чуть более подробное есть на [странице курса](https://skkv-itmo.gitbook.io/mt-course/opencl/opencl-platforms).
