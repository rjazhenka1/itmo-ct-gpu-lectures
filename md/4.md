# Произведение матриц

Чем больше регистров мы используем, тем меньше у нас thread'ов, которые мы можем использовать. **Occupancy** - сколько thread'ов мы используем относительно максимума. В целом, если доступов к памяти у нас относительно немного - ничего страшного. А вот если много - то можем встать в ожидании этого самого доступа к памяти.

Компилятор может нам сказать, что пошло не так и у нас уменьшился Occupancy.

Первый шаг к нашей первой лабораторной!!!

Как бы было, если бы мы писали на процессоре:

$N$ - x

$K$ - общая размерность входных матриц

$M$ - y

```c
for (y)
    for (x)
        for (k)
            c[][] += a[][] * b[][]

```

На процессоре - норм.
На видеокарте - ужасно медленно - 4 обращения к глобальной памяти за итерацию!!! (READ c, READ a, READ b, WRITE c)

Первая оптимизация:

```c
for (y)
    for (x)
        {
            sum = 0
            for (k)
                sum += a[][] * b[][]
            c[][] = sum
        }

```

Теперь у нас на каждой итерации всего лишь 2 обращения - (READ a, READ b)

Сколько нам нужно thread'ов? Много (с)

```c
        uint x = get_global_id(0);
        uint y = get_global_id(1);
        {
            sum = 0
            for (k)
                sum += a[][] * b[][]
            c[][] = sum
        }

```

Размерности - нулевая размерность будет соответствовать N, первая M;

M, N, K передаем как unsigned int

A имеет размер N х K, матрица B — K х M, и матрица C — N х M.

---

Домашнее задание: 
* сделать на хосте еще подсчет матриц с помощью OpenMP для сравнения.
* Вычислить время работы kernel'а на OpenMP и Open CL
* Сравнить время работы реализаций (Можно с помощью Events)
* Измерить FLOPS

**Пример решения лежит в [папке в примерами](../examples/4).**